name: Publish Notes to Twitter

on:
  # Trigger after notes scraper completes successfully
  workflow_run:
    workflows: ["Substack Notes Scraper"]
    types:
      - completed

  # Allow manual trigger for testing
  workflow_dispatch:

jobs:
  publish-notes:
    runs-on: ubuntu-latest
    # Only run if the notes workflow succeeded (or if manually triggered)
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event.workflow_run.conclusion == 'success'

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install tweepy pyyaml requests Pillow

      - name: Check for unpublished notes and post to Twitter
        env:
          TWITTER_API_KEY: ${{ secrets.TWITTER_API_KEY }}
          TWITTER_API_SECRET: ${{ secrets.TWITTER_API_SECRET }}
          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}
          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}
        run: |
          python3 << 'EOF'
          import os
          import re
          import time
          import yaml
          from pathlib import Path
          from datetime import datetime
          import tweepy

          def parse_frontmatter(content):
              """Extract frontmatter from markdown content."""
              match = re.match(r'^---\n(.*?)\n---', content, re.DOTALL)
              if not match:
                  return {}

              frontmatter = {}
              for line in match.group(1).split('\n'):
                  if ':' in line:
                      key, value = line.split(':', 1)
                      frontmatter[key.strip()] = value.strip()
              return frontmatter

          def extract_content(content):
              """Extract main content from note (after frontmatter and metadata)."""
              # Remove frontmatter
              content = re.sub(r'^---\n.*?\n---\n+', '', content, flags=re.DOTALL)

              # Remove title heading (may have whitespace before it)
              content = re.sub(r'^\s*#\s+.*?\n+', '', content, flags=re.DOTALL)

              # Remove metadata section (**Published:** ... **Link:** ... \n---)
              content = re.sub(r'^\*\*Published:.*?^---\n+', '', content, flags=re.DOTALL | re.MULTILINE)

              return content.strip()

          def format_for_twitter(content):
              """Convert Markdown formatting to Twitter-friendly text."""
              # Preserve the content but clean up markdown syntax for Twitter
              # Twitter doesn't support Markdown, so we'll keep basic formatting

              # Remove markdown images ![alt](url) - images will be attached via media_ids
              content = re.sub(r'!\[([^\]]*)\]\([^\)]+\)', '', content)

              # Convert bold (**text** or __text__) - just keep the text
              # Twitter doesn't have bold, but we can use Unicode alternatives if needed
              content = re.sub(r'\*\*([^*]+)\*\*', r'\1', content)
              content = re.sub(r'__([^_]+)__', r'\1', content)

              # Convert italic (*text* or _text_) - just keep the text
              content = re.sub(r'\*([^*]+)\*', r'\1', content)
              content = re.sub(r'_([^_]+)_', r'\1', content)

              # Convert inline code (`code`) - just keep the text
              content = re.sub(r'`([^`]+)`', r'\1', content)

              # Convert markdown links [text](url) to just text with URL after
              # Twitter auto-links URLs, so we can just show the URL
              content = re.sub(r'\[([^\]]+)\]\(([^\)]+)\)', r'\1: \2', content)

              # Remove heading markers (# ## ###)
              content = re.sub(r'^#{1,6}\s+', '', content, flags=re.MULTILINE)

              # Remove horizontal rules (---, ___, ***)
              content = re.sub(r'^[\-_*]{3,}$', '', content, flags=re.MULTILINE)

              # Clean up multiple newlines (keep max 2 for paragraph breaks)
              content = re.sub(r'\n{3,}', '\n\n', content)

              return content.strip()

          def post_to_twitter(twitter_client, content, url, premium_mode=False, note_folder=None):
              """Post note to Twitter using tweepy. Returns tweet_id on success, None on failure."""
              if not twitter_client:
                  print("âš ï¸  Twitter credentials not set, skipping post")
                  return None

              try:
                  media_ids = []

                  # Handle images in premium mode
                  if premium_mode and note_folder:
                      print("ðŸ–¼ï¸  Checking for images to include...")
                      # Look for image files in the note folder
                      image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp']
                      image_files = []

                      for ext in image_extensions:
                          image_files.extend(list(note_folder.glob(f'*{ext}')))
                          image_files.extend(list(note_folder.glob(f'*{ext.upper()}')))

                      # Twitter allows up to 4 images per tweet
                      image_files = sorted(image_files)[:4]

                      if image_files:
                          print(f"ðŸ“¸ Found {len(image_files)} image(s) to upload")
                          # Upload images to Twitter
                          api_key = os.environ.get('TWITTER_API_KEY')
                          api_secret = os.environ.get('TWITTER_API_SECRET')
                          access_token = os.environ.get('TWITTER_ACCESS_TOKEN')
                          access_token_secret = os.environ.get('TWITTER_ACCESS_TOKEN_SECRET')

                          # Use tweepy API v1.1 for media upload
                          import tweepy
                          auth = tweepy.OAuth1UserHandler(
                              api_key, api_secret, access_token, access_token_secret
                          )
                          api_v1 = tweepy.API(auth)

                          for img_file in image_files:
                              try:
                                  media = api_v1.media_upload(filename=str(img_file))
                                  media_ids.append(media.media_id)
                                  print(f"  âœ“ Uploaded: {img_file.name}")
                              except Exception as e:
                                  print(f"  âœ— Failed to upload {img_file.name}: {e}")
                      else:
                          print("  No images found in note folder")

                  # Format tweet based on premium mode
                  if premium_mode:
                      # Premium mode: Post full content with formatting preserved
                      print("ðŸ“± Using Twitter Premium mode - posting full content with formatting")
                      formatted_content = format_for_twitter(content)
                      tweet_text = formatted_content + f'\n\nðŸ‘‰ {url}'
                  else:
                      # Free mode: Use current truncation logic (280 char limit)
                      print("ðŸ“± Using Twitter Free mode - truncating to 280 chars")
                      # Leave room for URL (23 chars) + formatting
                      max_content_length = 250

                      if len(content) > max_content_length:
                          tweet_text = content[:max_content_length].rsplit(' ', 1)[0] + '...\n\n'
                      else:
                          tweet_text = content + '\n\n'

                      tweet_text += f"ðŸ‘‰ {url}"

                      # Ensure tweet doesn't exceed 280 characters
                      if len(tweet_text) > 280:
                          # Recalculate with smaller content
                          max_content_length = 280 - len(f"\n\nðŸ‘‰ {url}") - 3  # -3 for "..."
                          tweet_text = content[:max_content_length].rsplit(' ', 1)[0] + f'...\n\nðŸ‘‰ {url}'

                  # Post tweet with media if available
                  if media_ids:
                      response = twitter_client.create_tweet(text=tweet_text, media_ids=media_ids)
                      print(f"  ðŸ“Ž Attached {len(media_ids)} image(s)")
                  else:
                      response = twitter_client.create_tweet(text=tweet_text)

                  tweet_id = response.data['id']

                  print(f"âœ“ Successfully posted to Twitter")
                  print(f"  Tweet ID: {tweet_id}")
                  print(f"  Tweet URL: https://twitter.com/i/web/status/{tweet_id}")
                  print(f"  Length: {len(tweet_text)} chars")
                  print(f"  Preview: {tweet_text[:100]}...")

                  return tweet_id

              except tweepy.TweepyException as e:
                  print(f"âœ— Twitter API error: {e}")
                  return None
              except Exception as e:
                  print(f"âœ— Error posting to Twitter: {e}")
                  return None

          # Main logic
          notes_dir = Path('substack-scraper/notes')

          # Read Twitter Premium setting from config file
          config_path = Path('substack-scraper/twitter.yaml')
          twitter_premium = False  # Default to free mode

          if config_path.exists():
              try:
                  with open(config_path, 'r') as f:
                      config = yaml.safe_load(f)
                      twitter_premium = config.get('twitter', {}).get('premium', False)
                  print(f"ðŸ”§ Twitter Premium Mode: {'Enabled' if twitter_premium else 'Disabled'}")
              except Exception as e:
                  print(f"âš ï¸  Error reading twitter.yaml: {e}")
                  print(f"ðŸ”§ Defaulting to Twitter Free Mode")
          else:
              print(f"âš ï¸  twitter.yaml not found")
              print(f"ðŸ”§ Defaulting to Twitter Free Mode")

          # Initialize Twitter client
          api_key = os.environ.get('TWITTER_API_KEY')
          api_secret = os.environ.get('TWITTER_API_SECRET')
          access_token = os.environ.get('TWITTER_ACCESS_TOKEN')
          access_token_secret = os.environ.get('TWITTER_ACCESS_TOKEN_SECRET')

          twitter_client = None
          if api_key and api_secret and access_token and access_token_secret:
              try:
                  twitter_client = tweepy.Client(
                      consumer_key=api_key,
                      consumer_secret=api_secret,
                      access_token=access_token,
                      access_token_secret=access_token_secret
                  )
                  print("âœ“ Twitter client initialized")
              except Exception as e:
                  print(f"âœ— Failed to initialize Twitter client: {e}")
                  exit(1)
          else:
              print("âœ— Twitter credentials not set. Please add secrets:")
              print("  - TWITTER_API_KEY")
              print("  - TWITTER_API_SECRET")
              print("  - TWITTER_ACCESS_TOKEN")
              print("  - TWITTER_ACCESS_TOKEN_SECRET")
              exit(1)

          if not notes_dir.exists():
              print(f"Notes directory not found: {notes_dir}")
              exit(0)

          published_count = 0

          # Iterate through all note folders
          for note_folder in sorted(notes_dir.iterdir()):
              if not note_folder.is_dir():
                  continue

              # Check if already published
              published_marker = note_folder / '.published'
              if published_marker.exists():
                  print(f"â­ï¸  Skipping {note_folder.name} (already published)")
                  continue

              # Read original_note.md
              note_file = note_folder / 'original_note.md'
              if not note_file.exists():
                  print(f"âš ï¸  No original_note.md in {note_folder.name}")
                  continue

              try:
                  with open(note_file, 'r', encoding='utf-8') as f:
                      content = f.read()

                  # Parse frontmatter and content
                  frontmatter = parse_frontmatter(content)
                  main_content = extract_content(content)

                  note_id = frontmatter.get('note_id', '')
                  note_url = frontmatter.get('url', '')

                  print(f"\nðŸ“ Publishing note: {note_folder.name}")
                  print(f"   Note ID: {note_id}")
                  print(f"   URL: {note_url}")
                  print(f"   Content length: {len(main_content)} chars")

                  # Post to Twitter
                  tweet_id = post_to_twitter(twitter_client, main_content, note_url, twitter_premium, note_folder)

                  if tweet_id:
                      # Mark as published with tweet metadata
                      tweet_url = f"https://twitter.com/i/web/status/{tweet_id}"
                      with open(published_marker, 'w') as f:
                          f.write(f"published_at: {datetime.utcnow().isoformat()}Z\n")
                          f.write(f"tweet_id: {tweet_id}\n")
                          f.write(f"tweet_url: {tweet_url}\n")

                      published_count += 1
                      print(f"âœ“ Marked as published")

                      # Rate limiting - wait 10 seconds before next post
                      time.sleep(10)
                  else:
                      print(f"âœ— Failed to publish, will retry next run")

              except Exception as e:
                  print(f"âœ— Error processing {note_folder.name}: {e}")
                  continue

          print(f"\n{'='*50}")
          print(f"Published {published_count} new note(s) to Twitter")
          print(f"{'='*50}")
          EOF

      - name: Check for changes
        id: git-check
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "New .published markers created"
          else
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "No new notes published"
          fi

      - name: Commit published markers
        if: steps.git-check.outputs.changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add substack-scraper/notes/**/.published
          git commit -m "Mark notes as published to Twitter

          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
          via [Happy](https://happy.engineering)

          Co-Authored-By: Claude <noreply@anthropic.com>
          Co-Authored-By: Happy <yesreply@happy.engineering>"
          git push
